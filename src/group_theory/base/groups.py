from abc import ABC
from random import sample

from group_theory.base.group_elements import (
    GroupElement,
)

class Group(ABC):
    def __init__(self, elements: list[GroupElement]):
        self.elements = elements
        self.order = len(self.elements)
        self.identity = self.get_identity()
        self.canonical_generators = None

    def get_identity(self) -> GroupElement:
        for g in self.elements:
            if g.is_identity():
                self.identity = g
                return g

    def __repr__(self):
        s = self.elements.__repr__()
        return s
    
    #def _repr_latex_(self):
    #    string = self.__repr__()
    #    return string

    def __mul__(self,other):
        from group_theory.constructions.cartesian_products import CartesianProduct
        return CartesianProduct(self,other)

    def __truediv__(self,other):
        if isinstance(other, Subgroup):
            if other.parent_group==self:
                from group_theory.constructions.quotient_groups import QuotientGroup
                return QuotientGroup(self,other)
            else:
                raise ValueError('the subgroup provided is not a subgroup of the provided parent group')
        else:
            raise TypeError('you must pass a valid subgroup to quotient by')

    def __eq__(self, other):
        return set(self.elements)==set(other.elements)
    
    def __ne__(self, other):
        return set(self.elements)!=set(other.elements)
    
    def __lt__(self, other):
        return set(self.elements).issubset(set(other.elements))
    
    def __le__(self, other):
        return set(self.elements).issubset(set(other.elements))
    
    def __gt__(self, other):
        return set(self.elements).issuperset(set(other.elements))
    
    def __ge__(self, other):
        return set(self.elements).issuperset(set(other.elements))
    
    def __hash__(self):
        return hash(frozenset(self.elements))
    
    def __getitem__(self, key): 
        return self.elements[key]
    
    def __iter__(self): 
        return iter(self.elements)
    
    def __len__(self):
        return len(self.elements)
    
    def is_trivial(self):
        if len(self.elements)==1 and self.elements[0].is_identity():
            return True
        else:
            return False

    def subgroup_generated_by(self, generators: list[GroupElement]):
        '''
        this algorithm is the "black-box" algo found here:
        https://groupprops.subwiki.org/w/index.php?title=Black-box_group_algorithm_for_finding_the_subgroup_generated_by_a_subset
        '''
        e = self.identity
        H = {e}
        F = {e}
        
        while F:
            K = {f*s for f in F for s in generators}
            K = K-H
            F = K
            H = F.union(H)
            
        return Subgroup(list(H), self)
    
    def get_random_generators(self) -> list[GroupElement]:
        generators = []
        elements = [g for g in self if not g.is_identity()]
        generators+=[sample(elements,1)[0]]
        generated_elements = self.subgroup_generated_by(generators).elements
        while len(generated_elements)!=self.order:
                elements = [g for g in elements if g not in generated_elements]
                generators+=[sample(elements,1)[0]]
                generated_elements = self.subgroup_generated_by(generators).elements
        self.generators = generators
        return generators
    
    def commutator_subgroup(self):
        if self.canonical_generators:
            '''
            if G is generated by a set S, then the commutator subgroup is the normal closure of the set of commutators of elements of S
            '''
            return self.subgroup_generated_by([g*x*y*(~x)*(~y)*(~g) for x in self.canonical_generators for y in self.canonical_generators for g in self.elements])
        elif self.generators:
            '''
            if G is generated by a set S, then the commutator subgroup is the normal closure of the set of commutators of elements of S
            '''
            return self.subgroup_generated_by([g*x*y*(~x)*(~y)*(~g) for x in self.generators for y in self.generators for g in self.elements])
        else:
            return self.subgroup_generated_by([x*y*(~x)*(~y) for x in self.elements for y in self.elements])
    
    def derived_series(self):
        last_subgroup = Subgroup(self.elements, self)
        D = [last_subgroup]
        G = last_subgroup.elements
        comm_subgroup = self.subgroup_generated_by([x*y*(~x)*(~y) for x in G for y in G])
        while  comm_subgroup != last_subgroup:
            D.append(comm_subgroup)
            last_subgroup = comm_subgroup
            G = last_subgroup.elements
            comm_subgroup = self.subgroup_generated_by([x*y*(~x)*(~y) for x in G for y in G])
        return D
    
    def is_solvable(self):
        return self.derived_series()[-1].is_trivial()

    def lower_central_series(self):
        pass

    def upper_central_series(self):
        pass

class Subgroup(Group):
    def __init__(self, elements: list[GroupElement], parent_group: Group):
        super().__init__( self.validate_inclusion(elements, parent_group.elements) )
        self.parent_group = parent_group
        self.canonical_generators = None

        # properties
        self._is_normal = None

    @staticmethod
    def validate_inclusion(element_list: list, element_superlist: list):
        element_superset = set(element_superlist)
        element_set = set(element_list)
        assert element_set.issubset(element_superset)
        return element_list
    
    # IMPORTANT - until this is called and returns true, 
    # the Subgroup instance may not actually be a subgroup
    def validate_subgroup(self):
        for g in self:
            for h in self:
                if g*(~h) not in self:
                    return False
        return True
    
    def __repr__(self):
        return str(self.elements)
    
    def __eq__(self, other):
        return set(self.elements)==set(other.elements)
    
    def __hash__(self):
        return hash((self.elements,self.parent_group))
    
    def __and__(self, other):
        if self.parent_group!= other.parent_group:
            raise ValueError('the subgroups must both be a subset of the same group')
        return Subgroup([x for x in self.elements if x in other.elements], self.parent_group)
    
    def __matmul__(self, other):
        if self.parent_group!= other.parent_group:
            raise ValueError('the subgroups must both be a subset of the same group')
        HK = {h*k for h in self for k in other}
        KH = {k*h for h in self for k in other}
        if HK==KH:
            return Subgroup(list(HK), self.parent_group)
        else: 
            return HK
    
    def get_identity(self) -> GroupElement:
        for g in self.elements:
            if g.is_identity():
                return g
    
    def left_coset(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return {g*x for x in self.elements}
    
    def right_coset(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return {x*g for x in self.elements}
    
    def conjugate_subgroup(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return Subgroup([g*x*(~g) for x in self], self.parent_group)
    
    def check_normality(self):
        for g in set(self.parent_group):
            if self.left_coset(g)!=self.right_coset(g):
                return False
        return True

    @property
    def is_normal(self):
        if self._is_normal == None:
            self._is_normal = self.check_normality()
            return self._is_normal
        else:
            return self._is_normal
