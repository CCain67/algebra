from random import sample
from itertools import product

from group_theory.base.group_elements import (
    CartesianProductElement,
    GroupElement,
)

class Group:
    def __init__(self, elements: list[GroupElement]):
        self.elements = elements
        self.order = len(self.elements)
        self.identity = self.get_identity()
        self.canonical_generators = None

    def get_identity(self) -> GroupElement:
        for g in self.elements:
            if g.is_identity():
                self.identity = g
                return g

    def __repr__(self):
        s = self.elements.__repr__()
        return s

    def __mul__(self,other):
        '''
        this is the standard cartesian product of groups: for group G and H, G*H contains all
        pairs of elements of the form (g,h)
        '''
        product_elements = list(CartesianProductElement(g) for g in product(self.elements,other.elements))
        return Group(product_elements)

    def __truediv__(self,other):
        if isinstance(other, Subgroup):
            if other.parent_group==self:
                cosets = {Coset(g, other) for g in self}
                return Group(list(cosets))
            else:
                raise ValueError('the subgroup provided is not a subgroup of the provided parent group')
        else:
            raise TypeError('you must pass a valid subgroup to quotient by')

    def __eq__(self, other):
        return set(self.elements)==set(other.elements)
    
    def __ne__(self, other):
        return set(self.elements)!=set(other.elements)
    
    def __lt__(self, other):
        return set(self.elements).issubset(set(other.elements))
    
    def __le__(self, other):
        return set(self.elements).issubset(set(other.elements))
    
    def __gt__(self, other):
        return set(self.elements).issuperset(set(other.elements))
    
    def __ge__(self, other):
        return set(self.elements).issuperset(set(other.elements))
    
    def __hash__(self):
        return hash(frozenset(self.elements))
    
    def __getitem__(self, key): 
        return self.elements[key]
    
    def __iter__(self): 
        return iter(self.elements)
    
    def __len__(self):
        return len(self.elements)
    
    def is_trivial(self):
        if len(self.elements)==1 and self.elements[0].is_identity():
            return True
        else:
            return False

    def subgroup_generated_by(self, generators: list[GroupElement]):
        '''
        this algorithm is the "black-box" algo found here:
        https://groupprops.subwiki.org/w/index.php?title=Black-box_group_algorithm_for_finding_the_subgroup_generated_by_a_subset
        '''
        e = self.identity
        H = {e}
        F = {e}
        
        while F:
            K = {f*s for f in F for s in generators}
            K = K-H
            F = K
            H = F.union(H)
            
        return Subgroup(list(H), self)
    
    def get_random_generators(self) -> list[GroupElement]:
        generators = []
        elements = [g for g in self if not g.is_identity()]
        generators+=[sample(elements,1)[0]]
        generated_elements = self.subgroup_generated_by(generators).elements
        while len(generated_elements)!=self.order:
                elements = [g for g in elements if g not in generated_elements]
                generators+=[sample(elements,1)[0]]
                generated_elements = self.subgroup_generated_by(generators).elements
        self.generators = generators
        return generators
    
    def commutator_subgroup(self):
        if self.canonical_generators:
            '''
            if G is generated by a set S, then the commutator subgroup is the normal closure of the set of commutators of elements of S
            '''
            return self.subgroup_generated_by([g*x*y*(~x)*(~y)*(~g) for x in self.canonical_generators for y in self.canonical_generators for g in self.elements])
        elif self.generators:
            '''
            if G is generated by a set S, then the commutator subgroup is the normal closure of the set of commutators of elements of S
            '''
            return self.subgroup_generated_by([g*x*y*(~x)*(~y)*(~g) for x in self.generators for y in self.generators for g in self.elements])
        else:
            return self.subgroup_generated_by([x*y*(~x)*(~y) for x in self.elements for y in self.elements])
    
    def derived_series(self):
        last_subgroup = Subgroup(self.elements, self)
        D = [last_subgroup]
        G = last_subgroup.elements
        comm_subgroup = self.subgroup_generated_by([x*y*(~x)*(~y) for x in G for y in G])
        while  comm_subgroup != last_subgroup:
            D.append(comm_subgroup)
            last_subgroup = comm_subgroup
            G = last_subgroup.elements
            comm_subgroup = self.subgroup_generated_by([x*y*(~x)*(~y) for x in G for y in G])
        return D
    
    def is_solvable(self):
        return self.derived_series()[-1].is_trivial()

    def lower_central_series(self):
        pass

    def upper_central_series(self):
        pass

class Subgroup(Group):
    def __init__(self, elements: list[GroupElement], parent_group: Group):
        super().__init__(elements)
        self.parent_group = parent_group
        self.canonical_generators = None

        # properties
        self._is_normal = None

    def validate_inclusion(self):
        return set(self.elements).issubset(self.parent_group.elements)
    
    # IMPORTANT - until this is called and returns true, 
    # the Subgroup instance may not actually be a subgroup
    def validate_subgroup(self):
        for g in self:
            for h in self:
                if g*(~h) not in self:
                    return False
        return True
    
    def __repr__(self):
        return str(self.elements)
    
    def __eq__(self, other):
        return set(self.elements)==set(other.elements)
    
    def __hash__(self):
        return hash((self.elements,self.parent_group))
    
    def __and__(self, other):
        if self.parent_group!= other.parent_group:
            raise ValueError('the subgroups must both be a subset of the same group')
        return Subgroup([x for x in self.elements if x in other.elements], self.parent_group)
    
    def __matmul__(self, other):
        if self.parent_group!= other.parent_group:
            raise ValueError('the subgroups must both be a subset of the same group')
        HK = {h*k for h in self for k in other}
        KH = {k*h for h in self for k in other}
        if HK==KH:
            return Subgroup(list(HK), self.parent_group)
        else: 
            return HK
    
    def get_identity(self) -> GroupElement:
        for g in self.elements:
            if g.is_identity():
                return g
    
    def left_coset(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return {g*x for x in self.elements}
    
    def right_coset(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return {x*g for x in self.elements}
    
    def conjugate_subgroup(self, g: GroupElement):
        if g not in self.parent_group:
            raise ValueError('group element must be a member of the parent group')
        return Subgroup([g*x*(~g) for x in self], self.parent_group)
    
    def check_normality(self):
        for g in set(self.parent_group):
            if self.left_coset(g)!=self.right_coset(g):
                return False
        return True

    @property
    def is_normal(self):
        if self._is_normal is None:
            self._is_normal = self.check_normality()
            return self._is_normal
        else:
            return self._is_normal

class Coset(GroupElement):
    '''
    this class is used to represent elements gH of quotient groups G/H 
    for elements g and normal subgroups H
    '''
    def __init__(self, g: GroupElement, subgroup: Subgroup) -> None:
        self.g, self.subgroup = self.validate_coset(g, subgroup)
        self.elements = [self.g*x for x in self.subgroup]

    def __repr__(self):
        return str(self.g)+'H'
    
    def __eq__(self, other):
        return set(self.elements)==set(other.elements)
    
    def __ne__(self, other):
        return set(self.elements)!=set(other.elements)
    
    def __hash__(self):
        return hash(frozenset(self.elements))
    
    def __getitem__(self, key): 
        return self.elements[key]
    
    def __iter__(self): 
        return iter(self.elements)
    
    def __len__(self):
        return len(self.elements)
    
    def __mul__(self,other):
        if self.subgroup!=other.subgroup:
            raise ValueError('the subgroups of each coset must match')
        return Coset(self.g*other.g, self.subgroup)
    
    def __invert__(self):
        return Coset(~self.g, self.subgroup)

    @staticmethod
    def validate_coset(g: GroupElement, subgroup: Subgroup):
        assert g in subgroup.parent_group, "the group element must lie in the parent group"
        return g, subgroup

    def get_order(self):
        return NotImplemented
    
    def is_identity(self):
        return self.g in self.subgroup