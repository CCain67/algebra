from typing import Callable, Tuple
from functools import reduce
from itertools import product

from group_theory.base.group_elements import (
    CartesianProductElement,
    GroupElement,
)
from group_theory.base.groups import (
    Group,
    Subgroup,
)

class Homomorphism:
    def __init__(self, domain: Group, morphism: Callable[[Tuple[GroupElement,...]],GroupElement], codomain: Group) -> None:
        self.domain = domain
        self.morphism = morphism
        self.codomain = codomain

        # properties
        self._graph = None
        self._image = None
        self._kernel = None
        self._is_iso = None

    def __repr__(self) -> str:
        s = ""
        for g in self.domain.generators:
            s += str(g)+' -> '+str(self.morphism(g))+'\n'
        return s
    
    def __eq__(self,other) -> bool:
        if self.domain != other.domain:
            raise ValueError('the domains of the homomorphisms are not equal')
        if self.codomain != other.codomain:
            raise ValueError('the codomains of the homomorphisms are not equal')
        return all([self.morphism(g)==other.morphism(g) for g in self.domain.generators])
    
    def __getitem__(self, g): 
        return self.morphism(g)

    def validate_homomorphism(self) -> bool:
        '''
        Explanation: this comes from the paper 'Computing with Group Homomorphisms' by Leedham-Green et. al.
        
        The main idea is that a map f:G -> H is a homomorphism if and only if the subgroup generated by (g,f(g)) 
        (see the method get_graph below) has trivial intersection with {1}xH in GxH, if and only if this 
        generated subgroup has the same order as G.
        '''
        return self.graph.order==self.domain.order
    
    @classmethod
    def from_action_on_generators(cls, domain: Group, generator_in_out_dict: dict, codomain: Group):
        if not set(domain.generators).issubset(set(generator_in_out_dict.keys())):
            raise ValueError('the generators of the domain must be present in the dictionary keys')
        
        generator_in_out_dict[domain.identity]=codomain.identity
        generator_representations = domain.get_generator_representations()
        in_out_dict = {g:reduce(lambda x,y: x*y, [generator_in_out_dict[x] for x in generator_representations[g]]) for g in domain}

        def f(g: GroupElement) -> GroupElement:
            return in_out_dict[g]
        
        return cls(domain, f, codomain)

    @classmethod
    def from_dict(cls, domain: Group, in_out_dict: dict, codomain: Group):
        def f(g: GroupElement) -> GroupElement:
            return in_out_dict[g]
        
        return cls(domain, f, codomain)
    
    def get_graph(self) -> Subgroup:
        '''
        this is the subgroup of the cartesian product GxH generated by (g,f(g)) for a map f:G -> H, mentioned in the docstring above
        '''
        augmented_generators = self.domain.generators+[a*b for a in self.domain.generators for b in self.domain.generators]
        G_times_H = self.domain*self.codomain
        element_image_pairs = [CartesianProductElement((x,self.morphism(x))) for x in augmented_generators]
        X = G_times_H.subgroup_generated_by(element_image_pairs)
        return X

    @property
    def graph(self):
        if self._graph is None:
            self._graph = self.get_graph()
            return self._graph
        else:
            return self._graph
    
    def get_image(self) -> Group:
        image_generators = [self.morphism(g) for g in self.domain.generators]
        return self.codomain.subgroup_generated_by(image_generators)

    @property
    def image(self):
        if self._image is None:
            self._image = self.get_image()
            return self._image
        else:
            return self._image
        
    def get_kernel(self) -> Subgroup:
        X = self.graph
        G_times_H = self.domain*self.codomain
        G_1 = Subgroup([p for p in G_times_H if p[1].is_identity()], G_times_H)
        return Subgroup([p[0] for p in (X & G_1)], self.domain)

    @property
    def kernel(self):
        if self._kernel is None:
            self._kernel = self.get_kernel()
            return self._kernel
        else:
            return self._kernel
        
    def check_iso(self) -> bool:
        '''
        this utilizes the fact that for two finite sets, if an injective map exists between them, and 
        the two sets are of equal order, then the map is a bijection. 
        '''
        if len(self.kernel)==1 and self.domain.order==self.codomain.order and self.validate_homomorphism():
            return True
        else:
            return False

    @property
    def is_iso(self):
        if self._is_iso is None:
            self._is_iso = self.check_iso()
            return self._is_iso
        else:
            return self._is_iso
        

def homomorphism_factory(in_out_dict: dict) -> Callable:
    def f(g: GroupElement) -> GroupElement:
        return in_out_dict[g]
    return f

class GroupHomSet:
    '''
    class representing the hom-set Hom(G,H) for two finite groups G and H.
    '''
    def __init__(self, domain: Group, codomain: Group) -> None:
        self.domain = domain
        self.codomain = codomain
        self.homomorphisms = self.get_all_homomorphisms()

    def __repr__(self):
        return str(self.homomorphisms)


    def get_all_homomorphisms(self):
        '''
        fetching all possible homomorphisms works here as follows:
        
        1. for each generator g of G, we find all elements h in H such that 
        order(h) divides order(g) - these are the candidates for the image of g
        
        2. if f:G -> H is a homomorphism, we must have f(xy)=f(x)f(y), so we 
        check that order(f(x)f(y)) divides order of xy. if not, we move on to the 
        next set of potential images of generators.

        3. once we are past this check, we call validate_homomorphism. if this passes,
        we append the homomorphism to the list.    
        '''
        possible_images = {g:[h for h in self.codomain if g.order%h.order==0] for g in self.domain.generators}

        possible_homomorphisms = product(*[possible_images[g] for g in possible_images.keys()])
        pre_hom_set = [{g:hom_base[i] for i, g in enumerate(possible_images.keys())} for hom_base in possible_homomorphisms]

        homset = []
        for in_out_dict in pre_hom_set:
            go_to_next_in_out = False
            augmented_in_out_dict = in_out_dict
            for a,b in product(self.domain.generators,self.domain.generators):
                if (a*b).order % (in_out_dict[a]*in_out_dict[b]).order==0:
                    augmented_in_out_dict[a*b] = augmented_in_out_dict[a]*augmented_in_out_dict[b]
                else:
                    go_to_next_in_out = True
                    break
            if go_to_next_in_out:
                continue
            F = Homomorphism(domain=self.domain,morphism=homomorphism_factory(in_out_dict),codomain=self.codomain)
            if F.validate_homomorphism():
                homset.append(F)
        return homset